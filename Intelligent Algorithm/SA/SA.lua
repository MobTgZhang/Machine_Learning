---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by mobtgzhang.
--- DateTime: 2021/1/25 下午2:37
---
-- 忽略字符串头部的空白字符
require("torch")
require("gnuplot")
require("lfs")
local function ltrim(input)
    return (string.gsub(input, "^[ \t\n\r]+", ""))
end
-- 忽略字符串尾部的空白字符
local function rtrim(input)
    return (string.gsub(input, "[ \t\n\r]+$", ""))
end
-- 忽略字符串首尾的空白字符
local function trim(input)
    return (string.gsub(input, "^%s*(.-)%s*$", "%1"))
end
local function GetData(filename)
    local fileRead = io.open(filename)
    assert(fileRead,"file open failed!")
    local fileTab = {}
    local flag = false
    while true do
        local line = fileRead:read()
        line = trim(line)
        if string.find(line,"EOF") then
            break
        elseif string.find(line,"NODE_COORD_SECTION") then
            flag = true
        elseif flag then
            local data = string.split(line," ")
            table.insert(fileTab,{tonumber(data[2]),tonumber(data[3])})
        end
    end
    return fileTab--内容读取完毕，返回表
end
-- 创建一个元表
local SA = {}
function SA:new(obj)
    obj = obj or {t0=100,tf=3,alpha=0.99,markov_len=10000}
    setmetatable(obj,self)
    self.__index = self
    return obj
end
function SA:solve(citymat)
    -- Get the number of the city
    local length = #citymat
    citymat = torch.Tensor(citymat)
    self.citymat = citymat

    local citys_x = citymat[{{},{1}}]:clone():squeeze()
    local citys_y = citymat[{{},{2}}]:clone():squeeze()
    --print(citys_x:t())
    citys_x = torch.repeatTensor(citys_x,length):resize(length,length)
    citys_y = torch.repeatTensor(citys_y,length):resize(length,length)
    -- create distance matrix
    local citys_distance = torch.sqrt(torch.pow(citys_x - citys_x:t(),2) + torch.pow(citys_y - citys_y:t(),2))
    local sol_new = torch.range(1,length)
    local sol_current = sol_new:clone()
    self.sol_best = sol_new:totable()
    -- calculate the length
    local E_current = 0
    for k = 1,length-1 do
        E_current = E_current + citys_distance[{sol_new[k], sol_new[k + 1]}]
    end
    E_current = E_current + citys_distance[{sol_new[-1], sol_new[1]}]
    local E_best = E_current
    self.length_list = {}
    local t = self.t0
    local epoches = 0
    while t>=self.tf do
        for step=1,self.markov_len do

            if math.random() <0.5 then
                --Change two points
                local ind1,ind2 = 0,0
                while (ind1==ind2) do
                    ind1 = 1+ math.ceil(math.random() * (length-1))
                    ind2 = 1+ math.ceil(math.random() * (length-1))
                end
                sol_new[ind1],sol_new[ind2] = sol_new[ind2],sol_new[ind1]

            else
                --Change three points
                local ind1,ind2,ind3 = 0,0,0
                while ((ind1 == ind2) or (ind1 == ind3) or (ind2 == ind3)) do
                    ind1 = 1 + math.ceil(math.random() * (length-1))
                    ind2 = 1 + math.ceil(math.random() * (length-1))
                    ind3 = 1 + math.ceil(math.random() * (length-1))
                end

                local tmp_list = {ind1,ind2,ind3}
                table.sort(tmp_list,function(a,b) return a<b end)

                ind1,ind2,ind3 = tmp_list[1],tmp_list[2],tmp_list[3]
                local change = function(tensor,ind1,ind2,ind3)
                    local raw = tensor:narrow(1,ind1,ind3-ind1):totable()
                    for k = ind1,ind3-1 do
                        tensor[k] = raw[ind3-k]
                    end
                    return tensor
                end
                sol_new = change(sol_new,ind1,ind2,ind3)
            end
            -- calculate the route
            local E_new = 0
            for k= 1,length - 1 do
                E_new = E_new + citys_distance[{sol_new[k],sol_new[k + 1]}]
            end
            E_new = E_new + citys_distance[{sol_new[-1],sol_new[1]}]
            if E_new < E_current then
                E_current = E_new
                sol_current = sol_new:clone()
                if E_new < E_best then
                    E_best = E_new
                    self.sol_best = sol_new:totable()
                end
            else
                if math.random()<math.exp(-(E_new-E_current)/t) then
                    E_current = E_new
                    sol_current = sol_new:clone()
                else
                    sol_new = sol_current:clone()
                end
                self.E_best = E_best
            end
        end
        table.insert(self.length_list,E_best)
        epoches =epoches +1
        print(string.format("epoches: %d,temperature:%.2f,length:%.2f",epoches,t,self.E_best))
        t = t*self.alpha
    end
end
function SA:draw(losspath,picpath)
    print(self.sol_best)
    print(self.E_best)
    local x = torch.linspace(0, #self.length_list-1, #self.length_list)
    local y = torch.Tensor(self.length_list)
    gnuplot.pngfigure(losspath)
    gnuplot.plot{x, y,"-"}
    gnuplot.title("loss")
    gnuplot.xlabel('X')
    gnuplot.ylabel('Y')
    gnuplot.plotflush()
    gnuplot.close()

    gnuplot.pngfigure(picpath)
    local points_x,points_y = {},{}
    for k=1,#self.sol_best-1 do
        local start = self.citymat[self.sol_best[k]]:totable()
        local end_p = self.citymat[self.sol_best[k+1]]:totable()
        table.insert(points_x,start[1])
        table.insert(points_x,end_p[1])
        table.insert(points_y,start[2])
        table.insert(points_y,end_p[2])
    end
    local start = self.citymat[self.sol_best[#self.sol_best]]:totable()
    local end_p = self.citymat[self.sol_best[1]]:totable()
    table.insert(points_x,start[1])
    table.insert(points_x,end_p[1])
    table.insert(points_y,start[2])
    table.insert(points_y,end_p[2])
    points_x,points_y = torch.LongTensor(points_x),torch.LongTensor(points_y)
    gnuplot.plot{points_x, points_y,"o"}
    gnuplot.title(string.format("length:%.2f",self.E_best))
    gnuplot.xlabel('X')
    gnuplot.ylabel('Y')
    gnuplot.plotflush()
    gnuplot.close()
end
local function main()
    -- 获取城市坐标信息
    local filename = "eil51.tsp"
    local citymat = GetData(filename)
    -- 定义参数信息
    local t0, tf, alpha, markov_len = 10,0.7, 0.99, 10000
    local model = SA:new{t0=t0, tf=tf, alpha=alpha, markov_len=markov_len}
    model:solve(citymat)
    local losspath = "loss.png"
    local picpath = "route.png"
    model:draw(losspath,picpath)
end
main()
